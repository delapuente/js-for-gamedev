
<!DOCTYPE HTML>
<html lang="es" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>The JavaScript execution model Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.2">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../../styles/website.css">
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../02-ejercicios/" />
    
    
    <link rel="prev" href="../0202-modelo-de-datos/" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Escribe para buscar" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../../01-intro/">
            
                <a href="../../01-intro/">
            
                    
                    The work environment
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" >
            
                <span>
            
                    
                    JavaScript basics
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../0201-poo/">
            
                <a href="../0201-poo/">
            
                    
                    Object-oriented programming
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../0202-modelo-de-datos/">
            
                <a href="../0202-modelo-de-datos/">
            
                    
                    The JavaScript data model
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.3.3" data-path="./">
            
                <a href="./">
            
                    
                    The JavaScript execution model
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../02-ejercicios/">
            
                <a href="../02-ejercicios/">
            
                    
                    Guided exercises
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="../02-practica/">
            
                <a href="../02-practica/">
            
                    
                    Practice
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.5.1" data-path="../02-practica/GUIDE.html">
            
                <a href="../02-practica/GUIDE.html">
            
                    
                    Guide
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5.2" data-path="../02-practica/TDD.html">
            
                <a href="../02-practica/TDD.html">
            
                    
                    TDD
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" >
            
                <span>
            
                    
                    JavaScript in the browser
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../../03-javascript-en-el-navegador/0301-dom/">
            
                <a href="../../03-javascript-en-el-navegador/0301-dom/">
            
                    
                    The browser & DOM
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../../03-javascript-en-el-navegador/0302-canvas/">
            
                <a href="../../03-javascript-en-el-navegador/0302-canvas/">
            
                    
                    Canvas
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../../03-javascript-en-el-navegador/03-ejercicios/index.md">
            
                <span>
            
                    
                    Guided exercises
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="../../03-javascript-en-el-navegador/03-practica/">
            
                <a href="../../03-javascript-en-el-navegador/03-practica/">
            
                    
                    Practice
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.4.1" data-path="../../03-javascript-en-el-navegador/03-practica/guia.html">
            
                <a href="../../03-javascript-en-el-navegador/03-practica/guia.html">
            
                    
                    Guide
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Publicado con GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../.." >The JavaScript execution model</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="the-javascript-execution-model">The JavaScript execution model</h1>
<p>One of JavaScript&apos;s signature features is its <strong>asynchronous execution model</strong>, where results are not immediately available, but will be in the future.</p>
<h2 id="scope-and-hoisting">Scope and <em>hoisting</em></h2>
<p>As in so many other languages, the names of variables can be reutilized to store different values, as long as they are located in <strong>different scopes</strong>.</p>
<p>A variable&apos;s <em>scope</em> is the segment of code where it can be used. Variables with the same name in different scopes are different variables.</p>
<p>In JavaScript, scope is the <strong>function&apos;s body</strong>, demarcated by the pair of braces <code>{</code> and <code>}</code> which follow the function&apos;s parameter list.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">introduction</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// This is a variable called text.</span>
    <span class="hljs-keyword">var</span> text = <span class="hljs-string">&apos;I\&apos;m Ziltoid, the Omniscient.&apos;</span>;
    greetings();
    <span class="hljs-built_in">console</span>.log(text);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greetings</span>(<span class="hljs-params">list</span>) </span>{
    <span class="hljs-comment">// And this is a DIFFERENT variable, also called text.</span>
    <span class="hljs-keyword">var</span> text = <span class="hljs-string">&apos;Greetings humans!&apos;</span>;
    <span class="hljs-built_in">console</span>.log(text);
}

introduction();
</code></pre>
<p>In JavaScript, functions can be defined within other functions, thereby enabling nested scopes.</p>
<p>Function nesting is useful when we want to use <strong>auxiliar functions</strong>, which are normally short.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEven</span>(<span class="hljs-params">list</span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEven</span>(<span class="hljs-params">n</span>) </span>{
        <span class="hljs-keyword">return</span> n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">return</span> list.filter(isEven);
}

getEven([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]);
</code></pre>
<p>Since the scope is that of the function itself, the same name in a nested function can refer to two things:</p>
<p>1) <strong>If it is used with <code>var</code></strong>, we are introducing <strong>another, different variable</strong>:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">introduction</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// This is a variable called text.</span>
    <span class="hljs-keyword">var</span> text = <span class="hljs-string">&apos;I\&apos;m Ziltoid, the Omniscient.&apos;</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greetings</span>(<span class="hljs-params">list</span>) </span>{
        <span class="hljs-comment">// And this is ANOTHER different variable called text.</span>
        <span class="hljs-keyword">var</span> text = <span class="hljs-string">&apos;Greetings humans!&apos;</span>;
        <span class="hljs-built_in">console</span>.log(text);
    }

    greetings();
    <span class="hljs-built_in">console</span>.log(text);
}

introduction();
</code></pre>
<p>In the above case, we say that the variable <code>text</code> from the nested function <code>greetings</code> <em>hides</em> the variable <code>text</code> from the function <code>introduction</code>.</p>
<p>Remember that, in order to introduce a new variable, we have to declare it with <code>var</code> before using it (or at the same time we are assigning it).</p>
<p>2) If we skip the word <code>var</code>, no new variable is created, but it is the existing one that is <strong>reused</strong>.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">introduction</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// This is a variable called text.</span>
  <span class="hljs-keyword">var</span> text = <span class="hljs-string">&apos;I\&apos;m Ziltoid, the Omniscient.&apos;</span>;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greetings</span>(<span class="hljs-params">list</span>) </span>{
    <span class="hljs-comment">// This is THE SAME variable called text as the one above.</span>
    text = <span class="hljs-string">&apos;Greetings humans!&apos;</span>;
    <span class="hljs-built_in">console</span>.log(text);
  }

  greetings();
  <span class="hljs-built_in">console</span>.log(text);
}

introduction();
</code></pre>
<h3 id="hoisting"><em>Hoisting</em></h3>
<p><em>Hoisting</em>, in the context of programming, refers to a mechanism some languages employ in regards to name declaration.</p>
<p>In JavaScript, it makes no difference at which point through a function we declare a variable. JavaScript parses any declaration as occurring at the beginning of the function.</p>
<p>I.e., this:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;i: &apos;</span>, i, <span class="hljs-string">&apos; j: &apos;</span>, j);
        }
    }
}
</code></pre>
<p>Is equivalent to this:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> i;
    <span class="hljs-keyword">var</span> j;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;i: &apos;</span>, i, <span class="hljs-string">&apos; j: &apos;</span>, j);
        }
    }
}
</code></pre>
<p>Do notice that JavaScript <strong><em>hoists</em> the declaration</strong> of the variable (it takes it to the beginning), not its initialization. That is the reason the following piece of code does not fail, but prints out <code>undefined</code>:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(i);
    <span class="hljs-keyword">var</span> i = <span class="hljs-number">5</span>;
}
f();
</code></pre>
<p>In <strong>strict mode</strong>, using a variable that has not been declared will cause an error.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(i);
    i = <span class="hljs-number">5</span>;
}
f();
</code></pre>
<p>This is not an issue with <strong>function declarations</strong>: when a function declaration is hoisted, it is hoisted as a whole, <em>definition included</em>.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEven</span>(<span class="hljs-params">list</span>) </span>{
    <span class="hljs-keyword">return</span> list.filter(isEven);

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEven</span>(<span class="hljs-params">n</span>) </span>{
        <span class="hljs-keyword">return</span> n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>;
    }
}

getEven([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]);
</code></pre>
<p>This allows a way of arranging code that might be clearer, placing auxiliar functions right after the functions that use them.</p>
<p>This way, just from a look at the first line of the function, we can know what it does.</p>
<pre><code class="lang-js">    <span class="hljs-keyword">return</span> list.filter(isEven);
</code></pre>
<p>And, should we still be in doubt, we can continue to read and look into what the auxiliar function does.</p>
<pre><code class="lang-js">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEven</span>(<span class="hljs-params">n</span>) </span>{
        <span class="hljs-keyword">return</span> n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>;
    }
</code></pre>
<p>Do notice that for this way of writing code to be clear, the names we use for auxiliar functions must be suitable, descriptive, and hint at the value they return.</p>
<h2 id="closures"><em>Closures</em></h2>
<p>Functions are data and are created every time a <code>function</code> instruction is found. This way, we can create functions that return functions.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildFunction</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; };
}

<span class="hljs-keyword">var</span> f = buildFunction();
<span class="hljs-keyword">var</span> g = buildFunction();

<span class="hljs-keyword">typeof</span> f === <span class="hljs-string">&apos;function&apos;</span>;
<span class="hljs-keyword">typeof</span> g === <span class="hljs-string">&apos;function&apos;</span>;

f();
g(); <span class="hljs-comment">// Both functions do the same thing...</span>

f !== g; <span class="hljs-comment">// ...but are NOT the same function</span>
</code></pre>
<p>On its own, this is not a very powerful mechanism; however, now that we know nested functions can access variables from higher scopes, we can do something like this:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newDie</span>(<span class="hljs-params">sides</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * sides) + <span class="hljs-number">1</span>;
  };
}
<span class="hljs-keyword">var</span> d100 = newDie(<span class="hljs-number">100</span>);
<span class="hljs-keyword">var</span> d20 = newDie(<span class="hljs-number">20</span>);

d100 !== d20; <span class="hljs-comment">// different, created in two different newDie calls.</span>

d100();
d20();
</code></pre>
<p>In JavaScript, functions <strong>retain access to variables from higher scopes</strong>. A function referring to any variable from a higher scope is called a <strong><em>closure</em></strong>.</p>
<p><strong>This does not affect the value of <code>this</code></strong>, which will continue to be the message&apos;s target.</p>
<h3 id="methods-closures-and-this">Methods, <em>closures</em> and <code>this</code></h3>
<p>Consider the following example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> diceUtils = {
    history: [], <span class="hljs-comment">// keeps a history of die rolls.</span>

    newDie: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sides</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">die</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> result = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * sides) + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">this</span>.history.push([<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(), sides, result]);
            <span class="hljs-keyword">return</span> result;
        }
    }
}
</code></pre>
<p>Our intent is to be able to create dice and keep a record of all the rolls we make with these dice.</p>
<p>However, this does not work:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> d10 = diceUtils.newDie(<span class="hljs-number">10</span>);
d10(); <span class="hljs-comment">// error!</span>
</code></pre>
<p>This is so because <strong><code>this</code> is always the message&apos;s target</strong> and <code>d10</code> is being called as if it were a function rather than a method.</p>
<p>Remember that we can make any function take a fixed value as <code>this</code> with <code>.apply()</code>; so this does work, although it is not very convenient:</p>
<pre><code class="lang-js">d10.apply(diceUtils);
d10.apply(diceUtils);
diceUtils.history;
</code></pre>
<p>What we need to do is to make it so that the function <code>die</code> within <code>newDie</code> will refer to the <code>this</code> from the higher scope, not its own.</p>
<p>We can achieve this in two different ways. The first is a mere play on variables, storing <code>this</code>to an auxiliar variable (in this case, <code>self</code>):</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> diceUtils = {
    history: [], <span class="hljs-comment">// keeps a history of die rolls.</span>

    newDie: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sides</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>; <span class="hljs-comment">// self is now the target of newDie.</span>

        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">die</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> result = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * sides) + <span class="hljs-number">1</span>;
            <span class="hljs-comment">// by using self, we refer to newDie&apos;s target.</span>
            self.history.push([<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(), sides, result]);
            <span class="hljs-keyword">return</span> result;
        }
    }
}
</code></pre>
<p>This does work, and is far more convenient:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> d10 = diceUtils.newDie(<span class="hljs-number">10</span>);
<span class="hljs-keyword">var</span> d6 = diceUtils.newDie(<span class="hljs-number">6</span>);
d10();
d6();
d10();
diceUtils.history;
</code></pre>
<p>The second way is to use the functions&apos; <strong><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind" target="_blank"><code>bind</code></a> method</strong>.</p>
<p>A function&apos;s <code>bind</code> method returns another function whose <code>this</code> will be the first parameter of <code>bind</code>. Thus:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> diceUtils = {
    history: [], <span class="hljs-comment">// keeps a history of die rolls.</span>

    newDie: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sides</span>) </span>{
        <span class="hljs-keyword">return</span> die.bind(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// a new function that calls die with its target set on the first parameter.</span>

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">die</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> result = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * sides) + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">this</span>.history.push([<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(), sides, result]);
            <span class="hljs-keyword">return</span> result;
        }
    }
}
</code></pre>
<p>Both forms are widely used, but the second is often seen written this way:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> diceUtils = {
    history: [], <span class="hljs-comment">// keeps a history of die rolls.</span>

    newDie: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sides</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">die</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> result = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * sides) + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">this</span>.history.push([<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(), sides, result]);
            <span class="hljs-keyword">return</span> result;
        }.bind(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// bind follows the function expression.</span>
    }
}
</code></pre>
<h2 id="modules">Modules</h2>
<p>This section introduces the <strong>modules</strong> feature, which is specific to Node.</p>
<p>One of the main disadvantages to JavaScript (<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/import" target="_blank">until next version</a>) is that there is no way of arranging code in modules.</p>
<p>Modules are useful for isolating related functionality: types, functions, constants, configuration&#x2026;</p>
<p>Node <em>does have modules</em> and, luckily, there are <strong>tools that simulate modules</strong> like Node&apos;s on the browser.</p>
<p>In Node, JavaScript files ending by <code>.js</code>are modules. Node allows us to expose or <strong>export functionality</strong> from a module, placing it within the object <code>module.exports</code>:</p>
<pre><code class="lang-js"><span class="hljs-comment">// In diceUtils.js</span>
<span class="hljs-meta">&quot;use strict&quot;</span>; <span class="hljs-comment">// sets the module to strict mode.</span>

<span class="hljs-keyword">var</span> history = [];

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newDie</span>(<span class="hljs-params">sides</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">die</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> result = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * sides) + <span class="hljs-number">1</span>;
        history.push([<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(), sides, result]);
        <span class="hljs-keyword">return</span> result;
    };
}

<span class="hljs-comment">// What is exported is actually the object module.exports!</span>
<span class="hljs-built_in">module</span>.exports.newDie = newDie;
<span class="hljs-built_in">module</span>.exports.history = history;
</code></pre>
<p>What is actually exported is <strong>always <code>module.exports</code></strong>, which starts out as an empty object:</p>
<pre><code class="lang-js"><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span>.exports;
<span class="hljs-built_in">module</span>.exports;
</code></pre>
<p>Now we can <strong>import that module</strong> within another:</p>
<pre><code class="lang-js"><span class="hljs-comment">// In cthulhuRpg.js</span>
<span class="hljs-meta">&quot;use strict&quot;</span>;

<span class="hljs-keyword">var</span> diceUtils = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;./diceUtils&apos;</span>);
<span class="hljs-keyword">var</span> d100 = diceUtils.newDie(<span class="hljs-number">100</span>);

<span class="hljs-keyword">var</span> howard = {
    sanity: <span class="hljs-number">45</span>,
    sanityCheck: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (d100() &lt;= <span class="hljs-keyword">this</span>.sanity) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;Horrifying, but I\&apos;ll manage. That was close.&apos;</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-built_in">console</span>.log(
                <span class="hljs-string">&apos;Ph\&apos;nglui mglw\&apos;nafh Cthulhu R\&apos;lyeh wgah\&apos;nagl fhtagn!&apos;</span>);
        }
    }
};
howard.sanityCheck();
</code></pre>
<p>In order to import one module from another we need to pass to <a href="https://nodejs.org/api/modules.html#modules_module_require_id" target="_blank"><code>require</code></a> the <strong>relative route</strong> to the module file we want to import.</p>
<p>If we pass a name instead of a route, we will access the <strong>default funcionality</strong> that comes with Node (modules that are part of the standard library, such as <code>path</code> or <code>fs</code>) or the one we install from third parties (for instance, modules installed with the npm package manager). We shall use this form in a couple of occasions later on.</p>
<h2 id="differences-in-scope-between-node-and-the-browser">Differences in scope between Node and the browser</h2>
<p>It has been said that scope in JavaScript is equivalent to the function, but we also know that we can open a console or a file and start declaring variables without need of writing functions.</p>
<p>This happens because we are using the <strong>global scope</strong>. The global scope is available both to the browser and Node.</p>
<pre><code class="lang-js"><span class="hljs-comment">// This is a variable called text within the GLOBAL scope.</span>
<span class="hljs-keyword">var</span> text = <span class="hljs-string">&apos;I\&apos;m Ziltoid, the Omniscient.&apos;</span>;

<span class="hljs-comment">// This is a function within the GLOBAL scope.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greetings</span>(<span class="hljs-params">list</span>) </span>{
    <span class="hljs-comment">// This is ANOTHER variable called text, within the function&apos;s scope.</span>
    <span class="hljs-keyword">var</span> text = <span class="hljs-string">&apos;Greetings humans!&apos;</span>;
    <span class="hljs-built_in">console</span>.log(text);
}

greetings();
<span class="hljs-built_in">console</span>.log(text);
</code></pre>
<p>However, there is a peculiarity to Node. The global scope is actually <em>local in regards to the file</em>. This means that:</p>
<pre><code class="lang-js"><span class="hljs-comment">// In a.js, text is only visible from within the FILE.</span>
<span class="hljs-meta">&quot;use strict&quot;</span>;
<span class="hljs-keyword">var</span> text = <span class="hljs-string">&apos;I\&apos;m Ziltoid, the Omniscient.&apos;</span>;

<span class="hljs-comment">// In b.js, text is only visible from within the FILE.</span>
<span class="hljs-meta">&quot;use strict&quot;</span>;
<span class="hljs-keyword">var</span> text = <span class="hljs-string">&apos;Greetings humans!&apos;</span>;

<span class="hljs-comment">// In a console run from the same directory as a &amp; b</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;./a&apos;</span>);
<span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;./b&apos;</span>);
text;
</code></pre>
<h2 id="events-and-asynchronous-programming">Events and asynchronous programming</h2>
<p>Try the following example (copy, paste and wait for 5 seconds):</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> fiveSeconds = <span class="hljs-number">5</span> * <span class="hljs-number">1000</span>; <span class="hljs-comment">// in milliseconds.</span>

<span class="hljs-comment">// This happens now.</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;T: &apos;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>());

setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// This happens after 5 seconds.</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;T + 5 seconds: &apos;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>());
}, fiveSeconds);

<span class="hljs-comment">// This happens immediately thereafter</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;T + delta: &apos;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>());
</code></pre>
<p>As may have realized, the message is completed after 5 seconds because what <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout" target="_blank"><code>setTimeout</code></a> does is to call the function as soon as the stated amount of milliseconds has elapsed.</p>
<p>We say a function is a <strong><em>callback</em></strong> if it is called at some point in the future &#x2013;that is to say, <strong>asynchronously</strong>&#x2013; in order to report on some result.</p>
<p>In the <code>setTimeout</code> example, the result is that the specified amount of time has passed.</p>
<h3 id="events">Events</h3>
<p>In this section we will look at the <strong><code>readline</code> module</strong>, which is specific to Node.</p>
<p>Asynchronous programming is used in JavaScript and other languages to <strong>model events</strong>, mainly input/output waits. In other words: milestones that happen without us knowing when.</p>
<p>Input/output &#x2013;from now on, I/O&#x2013; does not just consist of reading from files or network requests, but also waiting for an action on the user&apos;s part.</p>
<p>As an example, we shall implement a line-by-line dialog console. We will use the <a href="https://nodejs.org/api/readline.html" target="_blank"><code>readline</code></a> module, which is a part of the standard library that comes built in with node:</p>
<pre><code class="lang-js"><span class="hljs-comment">// In conversational.js</span>
<span class="hljs-meta">&quot;use strict&quot;</span>;

<span class="hljs-keyword">var</span> readline = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;readline&apos;</span>);

<span class="hljs-keyword">var</span> cmd = readline.createInterface({
    input: process.stdin,  <span class="hljs-comment">// this way, we reference the console as input.</span>
    output: process.stdout, <span class="hljs-comment">// and this way, as output.</span>
    prompt: <span class="hljs-string">&apos;(&#x256F;&#xB0;&#x25A1;&#xB0;&#xFF09;&#x256F; &apos;</span> <span class="hljs-comment">// what shows up in order to wait for user input.</span>
});
</code></pre>
<p>Launch that program with Node and you will see it does nothing, <strong>yet neither does it end</strong>. This is typical of asynchronous programs: the program remains in wait for something to happen. Press <code>ctrl+c</code> to terminate the program.</p>
<p>Now try this:</p>
<pre><code class="lang-js"><span class="hljs-comment">// Add at the end of conversational.js</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;Write something and press enter&apos;</span>);
cmd.prompt(); <span class="hljs-comment">// asks the user to write something.</span>

cmd.on(<span class="hljs-string">&apos;line&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">input</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;You have said &quot;&apos;</span> + input  + <span class="hljs-string">&apos;&quot;&apos;</span>);
    cmd.prompt(); <span class="hljs-comment">// asks the user to write something.</span>
});
</code></pre>
<p>What you have achieved here is to <strong>listen for the <code>line</code> event</strong> that happens <a href="https://nodejs.org/api/readline.html#readline_event_line" target="_blank">every time a new line character is input</a>.</p>
<p>Speaking of events, the function that is asynchronously executed is called <strong>listener</strong>, but it is not uncommon for it to be called <em>callback</em>.</p>
<p>Expressions like &quot;<strong>registering a <em>listener</em></strong> for an event&quot;, &quot;subscribing to an event&quot; or &quot;listening for an event&quot; mean utilizing the mechanism that allows the association of a function&apos;s execution to said event.</p>
<p>All of this said, we cannot exit the prior program yet. We need to make some further changes:</p>
<pre><code class="lang-js"><span class="hljs-comment">// Add to conversational.js</span>
cmd.on(<span class="hljs-string">&apos;line&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">input</span>) </span>{
    <span class="hljs-keyword">if</span> (input === <span class="hljs-string">&apos;exit&apos;</span>) {
        cmd.close();
    }
});

cmd.on(<span class="hljs-string">&apos;close&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;See you!&apos;</span>);
    process.exit(<span class="hljs-number">0</span>); <span class="hljs-comment">// exits Node.</span>
});
</code></pre>
<p>We have added a second <em>listener</em> to the <code>line</code> event and <strong>both will be run</strong>. The first manages the default behavior (which is to repeat what the user has typed in), and the second deals specifically with the <code>exit</code> command.</p>
<p>If the line is exactly <code>exit</code>, we will close the command line interface. This causes a <code>close</code> event and, when we receive it, we will use that event&apos;s <em>listener</em> in order to terminate the program.</p>
<p>The <code>on</code> method is an alias for <a href="https://nodejs.org/api/events.html#events_emitter_addlistener_eventname_listener" target="_blank"><code>addListener</code></a>.</p>
<p>We can remove a <em>listener</em> the same way we add it by using <a href="https://nodejs.org/api/events.html#events_emitter_removelistener_eventname_listener" target="_blank"><code>removeListener</code></a>,
or remove all of them with <a href="https://nodejs.org/api/events.html#events_emitter_removealllisteners_eventname" target="_blank"><code>removeAllListeners</code></a>.</p>
<p>We can listen for an event <strong>just once</strong> with <a href="https://nodejs.org/api/events.html#events_emitter_once_eventname_listener" target="_blank"><code>once</code></a>.</p>
<h3 id="event-emitters">Event emitters</h3>
<p>Now we shall cover the <code>EventEmitter</code> class, which is also specific to Node.</p>
<p>Events are not a standard mechanism to JavaScript. They are a convenient way of modeling certain types of problems; but a JavaScript object, on its own, <strong>has no event-emitting API</strong>.</p>
<p>In Node, we can rely on several alternatives in order to have objects emit events:</p>
<ul>
<li><p>Implementing our own event API.</p>
</li>
<li><p>Having our objects <strong>use</strong> an instance of <code>EventEmitter</code>.</p>
</li>
<li><p>Having our objects <strong>be instances</strong> of <code>EventEmitter</code>.</p>
</li>
</ul>
<p>The first option would imply the creation of our own <code>on</code> method, as well as the mechanisms for event emission. The second and third both use the <a href="https://nodejs.org/api/events.html#events_class_eventemitter" target="_blank"><code>EventEmitter</code></a> class, which already implements this API.</p>
<p>This is an example of option 3, which we will take as an opportunity to review the notion of inheritance:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;events&apos;</span>);
<span class="hljs-keyword">var</span> EventEmitter = events.EventEmitter;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Ship</span>(<span class="hljs-params"></span>) </span>{
    EventEmitter.apply(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>._ammunition = <span class="hljs-string">&apos;laser charges&apos;</span>;
}

Ship.prototype = <span class="hljs-built_in">Object</span>.create(EventEmitter.prototype);
Ship.prototype.constructor = Ship;

<span class="hljs-keyword">var</span> ship = <span class="hljs-keyword">new</span> Ship();
ship.on; <span class="hljs-comment">// it exists!</span>
</code></pre>
<p>Now that the ship can emit events, we shall make it emit an event by shooting.</p>
<pre><code class="lang-js">Ship.prototype.shoot = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;VOIP!&apos;</span>);
    <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">&apos;shoot&apos;</span>, <span class="hljs-keyword">this</span>._ammunition); <span class="hljs-comment">// part of the EventEmitter API.</span>
};

ship.on(<span class="hljs-string">&apos;shoot&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ammunition</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;THIS IS COMMAND. The ship has fired:&apos;</span>, ammunition);
});

ship.shoot();
</code></pre>
<p><strong>Emitting an event</strong> consists of calling the <a href="https://nodejs.org/api/events.html#events_emitter_emit_eventname_arg1_arg2" target="_blank"><code>emit</code></a> method, which will trigger the execution of the <em>listeners</em> that listen for this event.</p>
<p>Events are incredibly useful in the generic modeling of user interfaces.</p>
<p>To this end, models must <strong>publish</strong> what is happening to them: how they change, what they do&#x2026; all of it <strong>through events</strong>. User interfaces will <strong>subscribe</strong> to these events and will provide the necessary visual information.</p>
<p>This model also allows for several user interfaces to work simultaneously, all of them listening for the same events. However, it also allows us to divide an interface into other, more specialized ones, all of them listening for specific sets of events.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="../0202-modelo-de-datos/" class="navigation navigation-prev " aria-label="Previous page: The JavaScript data model">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../02-ejercicios/" class="navigation navigation-next " aria-label="Next page: Guided exercises">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"The JavaScript execution model","level":"1.3.3","depth":2,"next":{"title":"Guided exercises","level":"1.3.4","depth":2,"path":"02-javascript/02-ejercicios/index.md","ref":"02-javascript/02-ejercicios/index.md","articles":[]},"previous":{"title":"The JavaScript data model","level":"1.3.2","depth":2,"path":"02-javascript/0202-modelo-de-datos/index.md","ref":"02-javascript/0202-modelo-de-datos/index.md","articles":[]},"dir":"ltr"},"config":{"plugins":[],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"language":"es","gitbook":"*"},"file":{"path":"02-javascript/0203-modelo-de-ejecucion/index.md","mtime":"2017-08-22T18:17:00.000Z","type":"markdown"},"gitbook":{"version":"3.2.2","time":"2017-08-22T18:37:55.899Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

