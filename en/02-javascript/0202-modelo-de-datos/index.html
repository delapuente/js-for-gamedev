
<!DOCTYPE HTML>
<html lang="es" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>The JavaScript data model Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.2">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../../styles/website.css">
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../0203-modelo-de-ejecucion/" />
    
    
    <link rel="prev" href="../0201-poo/" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Escribe para buscar" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../../01-intro/">
            
                <a href="../../01-intro/">
            
                    
                    The work environment
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" >
            
                <span>
            
                    
                    JavaScript basics
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../0201-poo/">
            
                <a href="../0201-poo/">
            
                    
                    Object-oriented programming
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.3.2" data-path="./">
            
                <a href="./">
            
                    
                    The JavaScript data model
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../0203-modelo-de-ejecucion/">
            
                <a href="../0203-modelo-de-ejecucion/">
            
                    
                    The JavaScript execution model
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../02-ejercicios/">
            
                <a href="../02-ejercicios/">
            
                    
                    Guided exercises
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="../02-practica/">
            
                <a href="../02-practica/">
            
                    
                    Practice
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.5.1" data-path="../02-practica/GUIDE.html">
            
                <a href="../02-practica/GUIDE.html">
            
                    
                    Guide
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5.2" data-path="../02-practica/TDD.html">
            
                <a href="../02-practica/TDD.html">
            
                    
                    TDD
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" >
            
                <span>
            
                    
                    JavaScript in the browser
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../../03-javascript-en-el-navegador/0301-dom/">
            
                <a href="../../03-javascript-en-el-navegador/0301-dom/">
            
                    
                    The browser & DOM
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../../03-javascript-en-el-navegador/0302-canvas/">
            
                <a href="../../03-javascript-en-el-navegador/0302-canvas/">
            
                    
                    Canvas
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../../03-javascript-en-el-navegador/03-ejercicios/index.md">
            
                <span>
            
                    
                    Guided exercises
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="../../03-javascript-en-el-navegador/03-practica/">
            
                <a href="../../03-javascript-en-el-navegador/03-practica/">
            
                    
                    Practice
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.4.1" data-path="../../03-javascript-en-el-navegador/03-practica/guia.html">
            
                <a href="../../03-javascript-en-el-navegador/03-practica/guia.html">
            
                    
                    Guide
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Publicado con GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../.." >The JavaScript data model</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="the-javascript-data-model">The JavaScript data model</h1>
<p>Knowing a programming language basically means that we know its syntax, data model, execution model, and idioms.</p>
<p>Throughout this lesson, <a href="../0201-poo">you will code into JavaScript what you learned in the prior lesson</a>.</p>
<p>Not all languages allow a 1:1 translation of the concepts we have included in the model. For instance, JavaScript does not feature any mechanisms that allow for the creation of new types, but it does feature other mechanisms that allow for the implementation of a similar functionality.</p>
<h2 id="experimenting-with-javascript">Experimenting with JavaScript</h2>
<p>You are going to be experimenting with JavaScript, so you will need a quick way of inspecting expressions and obtaining feedback on what you are doing. The best way is to use the <strong>Node console</strong>. For instance:</p>
<pre><code>sh
$ node --use_strict
</code></pre><p>The option <code>--use_strict</code> enables JavaScript&apos;s strict mode, which simplifies some aspects of the language. Strict mode cuts back on some features, but its benefits outweigh its drawbacks.</p>
<p>Now you can try to insert some expressions:</p>
<pre><code>sh
&gt; 40 + 2
42
&gt; var point = { x: 1, y: 1 };
undefined
&gt; point
{ x: 1, y: 1 }
&gt; point.x
1
</code></pre><p>In order to clear the screen, press <code>ctrl+l</code>. To exit Node, press <code>ctrl+c</code> twice in succession. If Node seems to be unresponsive while typing an expression, press <code>ctrl+c</code> once to cancel the expression.</p>
<p>If you would rather not put up with the Node console, you can always write a program and use <code>console.log()</code> in order to display expressions on screen.</p>
<pre><code class="lang-js"><span class="hljs-comment">// in file test.js</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-number">40</span> + <span class="hljs-number">2</span>);
<span class="hljs-keyword">var</span> point = { x: <span class="hljs-number">1</span>, y: <span class="hljs-number">1</span> };
<span class="hljs-built_in">console</span>.log(point);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;Coordinate X:&apos;</span>, point.x);
</code></pre>
<p>Now run the program with Node:</p>
<pre><code>sh
$ node test.js
42
{ x: 1, y: 1 }
Coordinate X: 1
</code></pre><p>This lesson assumes you will be using a single Node console session, unless otherwise specified.</p>
<p>You can keep the same session logged on for most of the examples, but in the case that you find anything unexpected, you should try restarting the console before doing anything else. In order to restart the console, you have to <strong>exit and enter again</strong>.</p>
<p>It would be best for you to keep this text opened up in a window (or printed out), and the Node console on another.</p>
<h2 id="primitive-types">Primitive types</h2>
<p><strong>&quot;Primitive type&quot;</strong> is the name give a type that comes built into the language, and which allows for the creation of newer, more complex types. The primitive types in JavaScript are: <strong>boolean</strong>, <strong>number</strong>, <strong>string</strong>, <strong>object</strong>, and <strong>function</strong>.</p>
<pre><code class="lang-js"><span class="hljs-comment">// You can find more possible values for each of the types in the comments.</span>
<span class="hljs-keyword">var</span> bool = <span class="hljs-literal">true</span>; <span class="hljs-comment">// false</span>
<span class="hljs-keyword">var</span> number = <span class="hljs-number">1234.5</span>; <span class="hljs-comment">// 42, -Infinity, +Infinity</span>
<span class="hljs-keyword">var</span> text = <span class="hljs-string">&apos;I want to be a pirate!&apos;</span>; <span class="hljs-comment">// &quot;I want to be a pirate&quot;</span>
<span class="hljs-keyword">var</span> object = {}; <span class="hljs-comment">// [], null</span>
<span class="hljs-keyword">var</span> code = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; };
</code></pre>
<p>You can tell them from others because they respond differently to the <code>typeof</code> operator. Notice how the types are text strings:</p>
<pre><code class="lang-js"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>;
<span class="hljs-keyword">typeof</span> <span class="hljs-number">1234.5</span>;
<span class="hljs-keyword">typeof</span> <span class="hljs-string">&apos;I want to be a pirate!&apos;</span>;
<span class="hljs-keyword">typeof</span> {};
<span class="hljs-keyword">typeof</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; };
</code></pre>
<p>In JavaScript, it is possible to declare a variable without assigning a value to it. In this case, the variable&apos;s type would be <code>&apos;undefined&apos;</code>.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> x;
<span class="hljs-keyword">typeof</span> x;
x = <span class="hljs-number">5</span>; <span class="hljs-comment">// as soon as we give it a value, its type will cease to be undefined.</span>
<span class="hljs-keyword">typeof</span> x;
</code></pre>
<h3 id="objects-in-javascript">Objects in JavaScript</h3>
<p>From among all the types, we shall pay special attention to those whose values allow <strong>compositing</strong> with other values. These are of the <strong>object</strong> type.</p>
<p>In JavaScript, objects are collections of tagged values. For instance, if we want to represent the point <code>(10, 15)</code> in the XY plane, we can tag the value on the Y axis with the string <code>&apos;x&apos;</code>, and the value on the Y axis with the <code>&apos;y&apos;</code> string.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> point = { <span class="hljs-string">&apos;x&apos;</span>: <span class="hljs-number">10</span>, <span class="hljs-string">&apos;y&apos;</span>: <span class="hljs-number">15</span> };
</code></pre>
<p>Every tag/value pair is called an <strong>object property</strong>. In a less strict way of speaking, when we discuss an object&apos;s <strong>properties</strong>, we are usually referring to values, while what we usually mean by a <strong>property name</strong> is a tag.</p>
<p>If property names are written according to the JavaScript <a href="https://developer.mozilla.org/en-US/docs/Glossary/Identifier" target="_blank">identifier forming rules</a>, the quotes are unnecessary and can be skipped.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> point = { x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span> }; <span class="hljs-comment">// much more convenient.</span>
</code></pre>
<p>This is the most frequent case, the <em>recommended</em> one, and the one we shall use throughout this material; however, you should remember that under the hood, <strong>the property name is a string</strong>.</p>
<p>In order to access a property of an object, we use the brackets <code>[</code> <code>]</code> with the property name in between:</p>
<pre><code class="lang-js">point[<span class="hljs-string">&apos;x&apos;</span>];
point[<span class="hljs-string">&apos;y&apos;</span>];
</code></pre>
<p>Again, if we follow the identifier forming rules, we can use the (much easier to write) <strong>dot notation</strong> to access the property:</p>
<pre><code class="lang-js">point.x;
point.y;
</code></pre>
<p>We use the assignment operator to change the value of a property:</p>
<pre><code class="lang-js">point.x = <span class="hljs-number">0</span>;
point.y = <span class="hljs-number">0</span>;
point[<span class="hljs-string">&apos;x&apos;</span>] = <span class="hljs-number">0</span>;
point[<span class="hljs-string">&apos;y&apos;</span>] = <span class="hljs-number">0</span>;
</code></pre>
<p>If you access a <strong>non-existent property</strong>, you will obtain the value <code>undefined</code>:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> label = point.label; <span class="hljs-comment">// will be undefined. Check it out with typeof.</span>
</code></pre>
<p>We can create new properties at any time by assigning a value to them:</p>
<pre><code class="lang-js">point.label = <span class="hljs-string">&apos;origin&apos;</span>;
point;
</code></pre>
<h3 id="arrays">Arrays</h3>
<p><strong>Arrays</strong> are collections of <strong>ordered data</strong>.</p>
<p>Consider the command list in a videogame menu:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> menu = [<span class="hljs-string">&apos;Attack&apos;</span>, <span class="hljs-string">&apos;Defense&apos;</span>, <span class="hljs-string">&apos;Inventory&apos;</span>];
</code></pre>
<p>In this type of objects, order matters. Accessing the different values is done by using the <strong>item&apos;s index in the array</strong>, between brackets. Indices <em>begin from <code>0</code></em>, and not from <code>1</code>.</p>
<pre><code class="lang-js">menu[<span class="hljs-number">0</span>];
menu[<span class="hljs-number">1</span>];
menu[<span class="hljs-number">2</span>];
</code></pre>
<p>We can check an array&apos;s length by accessing its <code>length</code> property.</p>
<pre><code class="lang-js">menu.length;
</code></pre>
<p>Items can be added to the array&apos;s end by calling the <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/push" target="_blank"><code>push</code></a> method:</p>
<pre><code class="lang-js">menu.push(<span class="hljs-string">&apos;Magic&apos;</span>);
</code></pre>
<p>An item can also be removed from the end by using the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" target="_blank"><code>pop</code></a> method:</p>
<pre><code class="lang-js">menu.pop();
</code></pre>
<p>An array can be altered (have items added or removed from it) in any place by using the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank"><code>splice</code></a> method:</p>
<pre><code class="lang-js"><span class="hljs-comment">// Inspect the list after every operation.</span>
menu = [<span class="hljs-string">&apos;Attack&apos;</span>, <span class="hljs-string">&apos;Defense&apos;</span>, <span class="hljs-string">&apos;Inventory&apos;</span>];
menu.splice(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&apos;Magic&apos;</span>); <span class="hljs-comment">// add Magic before Inventory.</span>
menu.splice(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&apos;Ench. Inventory&apos;</span>); <span class="hljs-comment">// replace Magic and Inventory with Ench. Inventory.</span>
menu.splice(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&apos;Wait&apos;</span>); <span class="hljs-comment">// add Wait to list beginning.</span>
</code></pre>
<p>As is the case with objects, we can change any value at any time by using the assignment operator:</p>
<pre><code class="lang-js">menu[<span class="hljs-number">0</span>] = <span class="hljs-string">&apos;Special&apos;</span>; <span class="hljs-comment">// replace Wait with Special</span>
</code></pre>
<p>Again, as with objects, we can access a non-existent value and retrieve or assign it at any time:</p>
<pre><code class="lang-js">menu;
menu.length;
<span class="hljs-keyword">var</span> item = menu[<span class="hljs-number">10</span>];
<span class="hljs-keyword">typeof</span> item; <span class="hljs-comment">// will be undefined.</span>
menu[<span class="hljs-number">10</span>] = <span class="hljs-string">&apos;Secret&apos;</span>;
menu;
menu.length;
</code></pre>
<p>If we assign to an index beyond the current length, <strong>the array will be extended</strong> until that index is included.</p>
<h4 id="making-a-distinction-between-objects-and-arrays">Making a distinction between objects and arrays</h4>
<p>Both arrays and objects are of the <code>&apos;object&apos;</code> type, therefore it is necessary to use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray" target="_blank"><code>Array.isArray()</code></a> method to tell them apart.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> obj = {}; <span class="hljs-comment">// the void object is as valid as any other.</span>
<span class="hljs-keyword">var</span> arr = []; <span class="hljs-comment">// an empty list.</span>
<span class="hljs-keyword">typeof</span> obj; <span class="hljs-comment">// will be object.</span>
<span class="hljs-keyword">typeof</span> arr; <span class="hljs-comment">// will be object.</span>
<span class="hljs-built_in">Array</span>.isArray(obj); <span class="hljs-comment">// will be false.</span>
<span class="hljs-built_in">Array</span>.isArray(arr); <span class="hljs-comment">// will be true.</span>
</code></pre>
<h3 id="null"><code>null</code></h3>
<p>There is a last possible value for the object type, which is <code>null</code>. This value represents the <strong>absence of an object</strong>, and it normally has the following uses:</p>
<ul>
<li><p>In functions that query about an object, to indicate that the object has not been found.</p>
</li>
<li><p>In compositing relationships, to indicate that the composite object no longer needs the compositing object.</p>
</li>
</ul>
<p>For instance, in an RPG, we can query about the next living enemy in order to check whether the battle has to keep going:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNextAliveEnemy</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> nextEnemy;
  <span class="hljs-keyword">if</span> (aliveEnemies.length &gt; <span class="hljs-number">0</span>) {
    nextEnemy = aliveEnemies[<span class="hljs-number">0</span>];
  }
  <span class="hljs-keyword">else</span> {
    nextEnemy = <span class="hljs-literal">null</span>;
  }
  <span class="hljs-keyword">return</span> nextEnemy;
}
</code></pre>
<p>Or, in another example, consider a hero&apos;s character sheet:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> hero = { sword: <span class="hljs-literal">null</span>, shield: <span class="hljs-literal">null</span> };
hero.sword = { attack: <span class="hljs-number">20</span>, magic: <span class="hljs-number">5</span> }; <span class="hljs-comment">// take a sword.</span>
hero.sword = <span class="hljs-literal">null</span>; <span class="hljs-comment">// drop a sword.</span>
</code></pre>
<h3 id="object-compositing">Object compositing</h3>
<p>Objects and arrays allow any compositing of objects. That is to say, their values can be other objects, arrays, numbers, strings or functions.</p>
<p>The following example shows a possible RPG character sheet:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> hero = {
  name: <span class="hljs-string">&apos;Link&apos;</span>,
  life: <span class="hljs-number">100</span>,
  weapon: { kind: <span class="hljs-string">&apos;sword&apos;</span>, power: <span class="hljs-number">20</span>, magicPower: <span class="hljs-number">5</span> },
  defense: { kind: <span class="hljs-string">&apos;shield&apos;</span>, power: <span class="hljs-number">5</span>, magicPower: <span class="hljs-number">0</span> },
  <span class="hljs-comment">// Inventory in slots. Two empty slots and another with 5 potions.</span>
  inventory: [
    { item: <span class="hljs-literal">null</span>, count: <span class="hljs-number">0</span>},
    { item: <span class="hljs-literal">null</span>, count: <span class="hljs-number">0</span>},
    { item: { kind: <span class="hljs-string">&apos;potion&apos;</span>, power: <span class="hljs-number">15</span> }, count: <span class="hljs-number">5</span>}
  ]
};
</code></pre>
<p>Some properties:</p>
<pre><code class="lang-js">hero.name; <span class="hljs-comment">// hero&apos;s name</span>
hero.weapon.kind; <span class="hljs-comment">// type of weapon</span>
hero.inventory[<span class="hljs-number">0</span>]; <span class="hljs-comment">// first inventory slot</span>
hero.inventory[<span class="hljs-number">0</span>].item; <span class="hljs-comment">// what is in the first inventory slot</span>
hero.inventory[<span class="hljs-number">2</span>].item.power; <span class="hljs-comment">// power level of the item in the third inventory slot</span>
</code></pre>
<h2 id="identity-of-objects">Identity of objects</h2>
<p>In JavaScript, the equality operator is <code>===</code> (triple equal). This allows us to compare two objects and decide whether <strong>they are equal</strong>. There is also the inequality operator <code>!==</code>, which compares two objects and decides whether <strong>they are not equal</strong>.</p>
<p>For the types <code>&apos;bool&apos;</code>, <code>&apos;string&apos;</code>, <code>&apos;number&apos;</code> &amp; <code>&apos;undefined&apos;</code>, two values are equal if they are <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators" target="_blank">of the <strong>same shape</strong></a>:</p>
<pre><code class="lang-js"><span class="hljs-comment">// All of these comparisons are true.</span>
<span class="hljs-string">&quot;Hola&quot;</span> === <span class="hljs-string">&quot;Hola&quot;</span>;
<span class="hljs-string">&quot;Hola&quot;</span> !== <span class="hljs-string">&quot;hola&quot;</span>;
<span class="hljs-literal">true</span> === <span class="hljs-literal">true</span>;
<span class="hljs-number">123</span> === <span class="hljs-number">123.0</span>;
<span class="hljs-number">123</span> !== <span class="hljs-string">&quot;123&quot;</span>;
<span class="hljs-number">123</span> === <span class="hljs-number">122</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// the expression is first solved, then compared.</span>
<span class="hljs-literal">undefined</span> === <span class="hljs-literal">undefined</span>;
</code></pre>
<p>For the <code>object</code> type, two objects are equal only if they refer to the same object:</p>
<pre><code class="lang-js">({} !== {}); <span class="hljs-comment">// regardless of the shape, these are two different objects.</span>
({} !== []);
[] !== []; <span class="hljs-comment">// same as before.</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] !== [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// regardless of the shape, the objects are different.</span>
<span class="hljs-literal">null</span> === <span class="hljs-literal">null</span>; <span class="hljs-comment">// but with null it works, since there is only one null value.</span>
<span class="hljs-keyword">var</span> obj = {};
<span class="hljs-keyword">var</span> sameObj = obj;
<span class="hljs-keyword">var</span> another = {};
sameObj === obj; <span class="hljs-comment">// it works because both names refer to the same object.</span>
sameObj !== another; <span class="hljs-comment">// like before, different despite the same shape.</span>
</code></pre>
<h2 id="objects-and-message-passing">Objects and message passing</h2>
<p>JavaScript objects and the ability to use code as a value like any other allow us to codify the concepts of <em>object</em> and <em>message passing</em> from object-oriented programming.</p>
<h3 id="codifying-the-state">Codifying the state</h3>
<p>With everything we have seen until now, you should have enough knowledge to codify the state. The <strong>attribute set</strong> of the object in the object-oriented model translates into the <strong>property set</strong> of JavaScript objects.</p>
<p>In the <em>Space Invaders</em> example, the state of enemies comprised of:</p>
<p><img src="images/space-invaders-enemy-state-EN.png" alt="Enemy state in the Space Invaders model"></p>
<p>Can be codified as:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> enemy = {
  graphic: <span class="hljs-string">&apos;specie01.png&apos;</span>,
  currentDirection: <span class="hljs-string">&apos;right&apos;</span>,
  position: { x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span> },
  score: <span class="hljs-number">40</span>
};
</code></pre>
<p>The foremost limitation to JavaScript is that <strong>access to object properties cannot be restricted</strong> (i.e., there are no private properties). Because of this, there is nothing to prevent us from directly modifying the position.</p>
<pre><code class="lang-js">enemy.position.x = <span class="hljs-number">100</span>; <span class="hljs-comment">// perfectly valid.</span>
</code></pre>
<p>At most, we could warn the user against code that handles certain properties. A widespread practice in JavaScript is to add an underscore <code>_</code> to attributes we want to consider to be <strong>private</strong>:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> enemy = {
  _graphic: <span class="hljs-string">&apos;specie01.png&apos;</span>,
  _currentDirection: <span class="hljs-string">&apos;right&apos;</span>,
  _position: { x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span> },
  _score: <span class="hljs-number">40</span>
};
</code></pre>
<p>However, we stress that this is only a convention, and underscore-marked attributes can be regardless accessed:</p>
<pre><code class="lang-js">enemy._position.x = <span class="hljs-number">100</span>; <span class="hljs-comment">// also perfectly valid.</span>
</code></pre>
<h3 id="codifying-the-api">Codifying the API</h3>
<p>The actions an object&apos;s API is comprised of, i.e. its <strong>methods</strong>, can be implemented as <strong>functions</strong> inside properties of the object.</p>
<p><img src="images/space-invaders-enemy-api-EN.png" alt="Enemy API in the Space Invaders model"></p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> enemy = {
  _graphic: <span class="hljs-string">&apos;specie01.png&apos;</span>,
  _currentDirection: <span class="hljs-string">&apos;right&apos;</span>,
  _position: { x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span> },
  _score: <span class="hljs-number">40</span>,

  moveLeft: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;Going left!&apos;</span>); },
  moveRight: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;Going right!&apos;</span>); },
  advance: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;Marching forward!&apos;</span>); },
  shoot: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;PEW!&apos;</span>); } <span class="hljs-comment">// (it&apos;s a laser)</span>
};
</code></pre>
<p><strong>Sending a message</strong> to an object simply means accessing the target&apos;s property, which will be a function, and calling it.</p>
<pre><code class="lang-js">enemy.shoot(); <span class="hljs-comment">// first we access with dot, then call with ().</span>
enemy.moveLeft();
enemy.moveLeft();
enemy.advance();
enemy[<span class="hljs-string">&apos;shoot&apos;</span>](); <span class="hljs-comment">// it is the same if we access with brackets and call with ().</span>
</code></pre>
<p>Any function can behave as a method. In order to have it act as a method, all we need is <strong>to call it from an object&apos;s property</strong>. And, like any other object property, we can change it at any time:</p>
<pre><code class="lang-js">enemy.shoot(); <span class="hljs-comment">// PEW!</span>
enemy.shoot = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;VOIP!&apos;</span>); };
enemy.shoot(); <span class="hljs-comment">// VOIP!</span>
</code></pre>
<p>Now then, notice the following behavior:</p>
<pre><code class="lang-js">enemy; <span class="hljs-comment">// notice the position.</span>
enemy.moveLeft();
enemy; <span class="hljs-comment">// notice the position again.</span>
</code></pre>
<p>Obviously, from just a glance at what <code>moveLeft</code> does, we would be unable to tell that it <em>changes the state</em> of the message&apos;s target object. How can we fix this?</p>
<p>Since any function can behave as a method, what we need is a way of <strong>referring to the message&apos;s target</strong>, if there is one. When used as a method, the target is always stored to the variable <strong><code>this</code></strong>.</p>
<p>Thanks to this variable, we can implement the following movement methods:</p>
<pre><code class="lang-js">enemy.moveLeft = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">this</span>._position.x -= <span class="hljs-number">2</span>; };
enemy.moveRight = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">this</span>._position.x += <span class="hljs-number">2</span>; };
enemy.advance = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">this</span>._position.y += <span class="hljs-number">2</span>; };
</code></pre>
<p>Try the same experiment as before and notice how we are, effectively, changing
the object&apos;s state.</p>
<pre><code class="lang-js">enemy; <span class="hljs-comment">// notice the position.</span>
enemy.moveLeft();
enemy; <span class="hljs-comment">// notice the position again.</span>
</code></pre>
<h3 id="the-value-of-this">The value of <code>this</code></h3>
<p>The value of <code>this</code> is one of JavaScript&apos;s most debated aspects.</p>
<p>In other languages, methods and functions are different things and a method
<em>always</em> has one &#x2013; and only one &#x2013; associated object, so <code>this</code> never changes.</p>
<p>But in JavaScript, <code>this</code> depends on how we call the function: whether we call
it as a function, or as a method.</p>
<p>Consider the following function:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inspect</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// only inspects this</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;Type:&apos;</span>, <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;Value:&apos;</span>, <span class="hljs-keyword">this</span>);
}
</code></pre>
<p>And try the following:</p>
<pre><code class="lang-js"><span class="hljs-comment">// before trying each example, consider what might the value of this be.</span>
<span class="hljs-keyword">var</span> ship1 = { name: <span class="hljs-string">&apos;T-Fighter&apos;</span>, method: inspect };
<span class="hljs-keyword">var</span> ship2 = { name: <span class="hljs-string">&apos;X-Wing&apos;</span>, method: inspect };
ship1.method();
ship2.method();
inspect();
</code></pre>
<p>In the latter case, the value of <code>this</code> is <code>undefined</code> because the function is not being used as a method, so there is no target.</p>
<p>In JavaScript, we can make a function take any object as its <code>this</code>. To do this, we shall use <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Function/apply" target="_blank"><code>apply</code></a> on a function.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> onlyNameShip = { name: <span class="hljs-string">&apos;Death Star&apos;</span> };
inspect.apply(onlyNameShip); <span class="hljs-comment">// makes the value of this be onlyNameShip for inspect.</span>
</code></pre>
<p><a href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/#this-value" target="_blank"><code>This</code></a> is also known as the <strong>context object</strong>, and we shall use this term occasionally throughout these materials.</p>
<h2 id="additional-considerations">Additional considerations</h2>
<h3 id="names-and-values">Names and values</h3>
<p><strong>A variable is a name.</strong> Names are meaningless to the program, save for some exceptions.</p>
<p><strong>A value is not a name.</strong> In fact, only functions can be named so that we can implement recursivity, as well as a couple extra things.</p>
<p>Therefore, the name <code>one</code> and the value <code>1</code> are not the same thing; and of course, there is no obligatory coherent relationship between name and value.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> uno = <span class="hljs-number">2</span>; <span class="hljs-comment">// makes sense to the program, maybe not so much to the programmer.</span>
</code></pre>
<p>Generally speaking, when dealing with booleans, strings and numbers, we say that <strong>names store values</strong>; while when speaking about objects and functions we say that <strong>names point</strong> to objects or functions, or that they <strong>reference</strong> objects or functions.</p>
<h3 id="functions-references-to-functions-and-calls-to-functions">Functions, references to functions and calls to functions</h3>
<p>There are two ways of defining a function. One is to use the <strong>function declaration</strong>, <code>function</code>:</p>
<pre><code class="lang-js"><span class="hljs-comment">// introduces a factorial variable which points to the factorial function.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factorial</span>(<span class="hljs-params">number</span>) </span>{
  <span class="hljs-keyword">if</span> (number === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  }
  <span class="hljs-keyword">return</span> number * factorial(number - <span class="hljs-number">1</span>);
} <span class="hljs-comment">// no semicolon &apos;;&apos; needed in this case.</span>
</code></pre>
<p>In this case, the name of the function (before the parentheses) is mandatory. Giving a name to a function has two implications:</p>
<ul>
<li><p>It allows the implementation of <strong>recursive calls</strong>, like the one in the example.</p>
</li>
<li><p><strong>It creates a name</strong>, <code>factorial</code>, to refer to that function by.</p>
</li>
</ul>
<p>The other way is to use a <strong>function expression</strong>. This is more similar to the way we would create other values, such as numbers or strings:</p>
<pre><code class="lang-js"><span class="hljs-comment">// Introduces a recursiveFunction variable that points to ANOTHER factorial function.</span>
<span class="hljs-keyword">var</span> recursiveFunction = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factorial</span>(<span class="hljs-params">number</span>) </span>{
  <span class="hljs-keyword">if</span> (number === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  }
  <span class="hljs-keyword">return</span> number * factorial(number - <span class="hljs-number">1</span>);
}; <span class="hljs-comment">// now we do need a semicolon, just as in any other assignment.</span>
</code></pre>
<p>In this last case, there are two names. One is the name of the function <code>factorial</code>, which exists so that we can refer to it within the function&apos;s body. The other is the <code>recursiveFunction</code> variable, which references the function.</p>
<p>The same function can be referenced by multiple variables or, put another way, have many names:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> a = recursiveFunction;
<span class="hljs-keyword">var</span> b = recursiveFunction;
a === b; <span class="hljs-comment">// true, they refer to the same function.</span>
a.name; <span class="hljs-comment">// the function name has nothing to do with that of the variable.</span>
b.name; <span class="hljs-comment">// same.</span>
recursiveFunction !== factorial;
</code></pre>
<p>Neither should we confuse the reference to the function <code>factorial</code> and the call to the same function, for example, <code>factorial(10)</code>.</p>
<p>The first expression <strong>refers to the object</strong> that encapsulates the code to be run. It requires no parameters because <strong>what we want is not to run the code</strong>, but to refer to the function.</p>
<p>With the second expression, <strong>we are asking the function to be executed</strong> and, therefore, all necessary parameters have to be provided.</p>
<h3 id="everything-is-an-object-in-javascript">Everything is an object in JavaScript</h3>
<p>If, according to an alternate definition, we consider an object to be anything that may respond to a message, then it results that <strong>everything is an object</strong> in JavaScript.</p>
<p>Notice the following examples:</p>
<pre><code class="lang-js"><span class="hljs-literal">true</span>.toString();
<span class="hljs-number">3.1415</span>.toFixed(<span class="hljs-number">2</span>);
<span class="hljs-string">&apos;I want to be a pirate!&apos;</span>.split(<span class="hljs-string">&apos; &apos;</span>);
({}).hasOwnProperty(<span class="hljs-string">&apos;x&apos;</span>);
(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parameter</span>) </span>{ <span class="hljs-keyword">return</span> parameter; }).length;
</code></pre>
<h2 id="types-and-object-constructors">Types and object constructors</h2>
<p>As we said before, JavaScript does not allow for the modeling of new types, which necessitates a &quot;workaround&quot;. This is one of its key differences with other object-oriented languages.</p>
<p>What we do is to sidestep the notion of <em>type</em> altogether, so as to directly introduce the concept of <strong><em>constructor</em></strong>.</p>
<p><img src="images/space-invaders-constructor-example-EN.png" alt="Object constructors"></p>
<p>We are going to create two constructor functions: one for points, another for shots.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newPoint</span>(<span class="hljs-params">x, y</span>) </span>{
    <span class="hljs-keyword">var</span> obj = {};
    obj.x = x;
    obj.y = y;

    <span class="hljs-keyword">return</span> obj;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newShot</span>(<span class="hljs-params">position, velocity</span>) </span>{
    <span class="hljs-keyword">var</span> obj = {};
    obj._position = position;
    obj._velocity = velocity;
    obj.advance = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>._position.y += <span class="hljs-keyword">this</span>._velocity;
    };

    <span class="hljs-keyword">return</span> obj;
}
</code></pre>
<p>Constructor functions are very similar in form: they create a void object, set the object&apos;s properties and return the new object.</p>
<p>Now we would be able to create shots with something like this:</p>
<pre><code class="lang-js"><span class="hljs-comment">// Positive velocity for downward movement.</span>
<span class="hljs-keyword">var</span> enemyShot = newShot(newPoint(<span class="hljs-number">15</span>, <span class="hljs-number">15</span>), <span class="hljs-number">2</span>);

<span class="hljs-comment">// Negative velocity for upwards movement.</span>
<span class="hljs-keyword">var</span> allyShot = newShot(newPoint(<span class="hljs-number">15</span>, <span class="hljs-number">585</span>), <span class="hljs-number">-2</span>);

enemyShot !== allyShot;
</code></pre>
<h3 id="reusing-functionality">Reusing functionality</h3>
<p>The problem with this approach is that we are creating different functions for identical behaviors: one function per object.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> s1 = newShot(newPoint(<span class="hljs-number">15</span>, <span class="hljs-number">15</span>), <span class="hljs-number">2</span>);
<span class="hljs-keyword">var</span> s2 = newShot(newPoint(<span class="hljs-number">15</span>, <span class="hljs-number">15</span>), <span class="hljs-number">2</span>);
<span class="hljs-keyword">var</span> s3 = newShot(newPoint(<span class="hljs-number">15</span>, <span class="hljs-number">15</span>), <span class="hljs-number">2</span>);
s1.advance !== s2.advance;
s2.advance !== s3.advance;
s3.advance !== s1.advance;
</code></pre>
<p>This is highly inefficient, since every function takes up its own space in memory.</p>
<p>There is no need for so many functions, but rather only one, affecting several objects.</p>
<p>Therefore, it is best to <strong>create an object that contains only the API</strong>:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> shotAPI = {
    advance: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>._position.y += <span class="hljs-keyword">this</span>._velocity;
    }
};
</code></pre>
<p>And use it in the object&apos;s creation so that it borrows the API&apos;s methods:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newShot</span>(<span class="hljs-params">position, velocity</span>) </span>{
    <span class="hljs-keyword">var</span> obj = {};
    obj._position = position;
    obj._velocity = velocity;
    obj.advance = shotAPI.advance;
    <span class="hljs-keyword">return</span> obj;
}
</code></pre>
<p>Now all instances share the same function, but every function affects the corresponding object, thanks to the value of <code>this</code>:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> s1 = newShot(newPoint(<span class="hljs-number">15</span>, <span class="hljs-number">15</span>), <span class="hljs-number">2</span>);
<span class="hljs-keyword">var</span> s2 = newShot(newPoint(<span class="hljs-number">15</span>, <span class="hljs-number">15</span>), <span class="hljs-number">2</span>);
<span class="hljs-keyword">var</span> s3 = newShot(newPoint(<span class="hljs-number">15</span>, <span class="hljs-number">15</span>), <span class="hljs-number">2</span>);
s1.advance === s2.advance; <span class="hljs-comment">// now they ARE the same.</span>
s2.advance === s3.advance;
s3.advance === s1.advance;
</code></pre>
<p>In order to further strengthen the association between constructor and API, we shall perform a minor modification: creating the object with the API as a <strong>property of the constructor function</strong>, thereby grouping everything in the same place (the <code>newShot</code> function).</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newShot</span>(<span class="hljs-params">position, velocity</span>) </span>{
    <span class="hljs-keyword">var</span> obj = {};
    obj._position = position;
    obj._velocity = velocity;
    obj.advance = newShot.api.advance;
    <span class="hljs-keyword">return</span> obj;
}

<span class="hljs-comment">// A function is an object, so we can add a property to it.</span>
newShot.api = {
    advance: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>._position.y += <span class="hljs-keyword">this</span>._velocity;
    }
};
</code></pre>
<h2 id="the-prototype-chain">The prototype chain</h2>
<p>JavaScript has a signature feature, unique to the language: the <strong>prototype chain</strong>.</p>
<p>You can experiment with it in <a href="http://www.objectplayground.com/" target="_blank">Object Playground</a>, an excellent tool that will help you visualize it.</p>
<p>The idea is not too complicated: the prototype chain is a <strong>property search list</strong>. Every item in the chain is the <strong>prototype</strong> of the prior item.</p>
<p>When you access a property of an object, this property is looked up in the object and if it is not found, it is looked up in the object&apos;s prototype, and so on until either the property or the chain&apos;s end are reached.</p>
<p>For instance:</p>
<pre><code>obj1                    obj2               obj3
{ a: 1, b: 2, c: 3} --&gt; { d: 4, e: 5 } --&gt; { f: 6 }
obj1.c -------&#x2191;           &#x2191;                  &#x2191;
obj1.d -------------------|                  |
obj1.f --------------------------------------|
obj1.z ------------------------------------------------X
</code></pre><p>Creating this hierarchy in JavaScript requires the use of <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Object/create" target="_blank"><code>Object.create()</code></a>:</p>
<pre><code class="lang-js"><span class="hljs-comment">// The chain is assembled from rear to front.</span>
<span class="hljs-keyword">var</span> obj3 = { f: <span class="hljs-number">6</span> };
<span class="hljs-comment">// Chaining obj2 to obj3</span>
<span class="hljs-keyword">var</span> obj2 = <span class="hljs-built_in">Object</span>.create(obj3);
obj2.d = <span class="hljs-number">4</span>;
obj2.e = <span class="hljs-number">5</span>;
<span class="hljs-comment">// Chaining obj1 to obj2</span>
<span class="hljs-keyword">var</span> obj1 = <span class="hljs-built_in">Object</span>.create(obj2);
obj1.a = <span class="hljs-number">1</span>;
obj1.b = <span class="hljs-number">2</span>;
obj1.c = <span class="hljs-number">3</span>;

obj1.c;
obj1.d;
obj1.f;
obj1.z; <span class="hljs-comment">// undefined</span>
</code></pre>
<p>The method <code>Object.create()</code> creates a new void object (like <code>{}</code>) whose prototype is the object we passed as a parameter.</p>
<p>The method <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" target="_blank"><code>hasOwnProperty</code></a> can be used to determine whether a property belongs to an object without having to go through the prototype chain:</p>
<pre><code class="lang-js">obj1.hasOwnProperty(<span class="hljs-string">&apos;c&apos;</span>); <span class="hljs-comment">// true</span>
obj1.hasOwnProperty(<span class="hljs-string">&apos;d&apos;</span>); <span class="hljs-comment">// false</span>
obj1.hasOwnProperty(<span class="hljs-string">&apos;f&apos;</span>); <span class="hljs-comment">// false</span>
obj1.hasOwnProperty(<span class="hljs-string">&apos;z&apos;</span>); <span class="hljs-comment">// false</span>

obj2.hasOwnProperty(<span class="hljs-string">&apos;c&apos;</span>); <span class="hljs-comment">// false</span>
obj2.hasOwnProperty(<span class="hljs-string">&apos;d&apos;</span>); <span class="hljs-comment">// true</span>
obj2.hasOwnProperty(<span class="hljs-string">&apos;f&apos;</span>); <span class="hljs-comment">// false</span>
obj2.hasOwnProperty(<span class="hljs-string">&apos;z&apos;</span>); <span class="hljs-comment">// false</span>

obj3.hasOwnProperty(<span class="hljs-string">&apos;c&apos;</span>); <span class="hljs-comment">// false</span>
obj3.hasOwnProperty(<span class="hljs-string">&apos;d&apos;</span>); <span class="hljs-comment">// false</span>
obj3.hasOwnProperty(<span class="hljs-string">&apos;f&apos;</span>); <span class="hljs-comment">// true</span>
obj3.hasOwnProperty(<span class="hljs-string">&apos;z&apos;</span>); <span class="hljs-comment">// false</span>
</code></pre>
<p>The method <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf" target="_blank"><code>Object.getPrototypeOf()</code></a> can be used to obtain an object&apos;s prototype:</p>
<pre><code class="lang-js"><span class="hljs-built_in">Object</span>.getPrototypeOf(obj1) === obj2;
<span class="hljs-built_in">Object</span>.getPrototypeOf(obj2) === obj3;
<span class="hljs-built_in">Object</span>.getPrototypeOf(obj3) === <span class="hljs-built_in">Object</span>.prototype;
<span class="hljs-built_in">Object</span>.getPrototypeOf(<span class="hljs-built_in">Object</span>.prototype) === <span class="hljs-literal">null</span>;
</code></pre>
<h2 id="constructors-and-prototype-chains">Constructors and prototype chains</h2>
<p>Prototypes are uniquely suited to contain the API, which is the common behavior to all objects of a given type.</p>
<pre><code>var obj = newShot()                               newShot.api
{ _position: { x: 10, y: 10 }, _velocity: 2 } --&gt; { advance: function ... };
obj._position.y ------&#x2191;                             &#x2191;
obj.advance ----------------------------------------|
obj.goBack ------------------------------------------------------------------X
</code></pre><p>In order to establish this link, we shall modify our constructor as follows:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newShot</span>(<span class="hljs-params">position, velocity</span>) </span>{
    <span class="hljs-comment">// With this, the API is the object&apos;s prototype.</span>
    <span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(newShot.api);
    obj._position = position;
    obj._velocity = velocity;

    <span class="hljs-keyword">return</span> obj;
}

newShot.api = {
    advance: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>._position.y += <span class="hljs-keyword">this</span>._velocity;
    }
};
</code></pre>
<p>Now try creating a new shot:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> shot = newShot({x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>}, <span class="hljs-number">2</span>);
shot; <span class="hljs-comment">// on inspecting shot, only the object&apos;s properties are shown.</span>
shot.advance; <span class="hljs-comment">// but advance exists in its prototype.</span>
shot.hasOwnProperty(<span class="hljs-string">&apos;advance&apos;</span>); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">Object</span>.getPrototypeOf(shot).hasOwnProperty(<span class="hljs-string">&apos;advance&apos;</span>); <span class="hljs-comment">// true</span>
</code></pre>
<p>If we do this for all constructors, we shall soon come across a pattern:</p>
<ol>
<li><p>Create an object to contain the API.</p>
</li>
<li><p>Implement the API as properties of this object.</p>
</li>
<li><p>Within the constructor, make this object be the prototype to a new object.</p>
</li>
<li><p>Establish the properties of the new object with the state.</p>
</li>
<li><p>Return the new object.</p>
</li>
</ol>
<p>Only steps 2 and 4 involve differences between this constructor and any others, the rest is exactly the same. So much so that JavaScript takes note of it, and comes with built-in mechanisms to automatize steps 1, 3 and 5.</p>
<p>First of all, JavaScript allows for <em>any function</em> to be used as a constructor. Because of this, everytime we type a function, JavaScript creates a <strong>property of the function called &quot;prototype&quot;</strong>, which is an object with a single property, <code>constructor</code>, that points to the function.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">anyFunction</span>(<span class="hljs-params"></span>) </span>{}
anyFunction.prototype;
anyFunction.prototype.constructor === anyFunction;
</code></pre>
<p>This automatizes step 1: no longer do we need the <code>api</code> object that we would manually set. The <code>prototype</code> property is equivalent to the <code>api</code> property.</p>
<p>Now, upon calling the function with the operator <code>new</code> first, <strong>a new object whose prototype is precisely the function&apos;s &quot;prototype&quot; property</strong> is created:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> anyFunction();
<span class="hljs-keyword">var</span> anotherObj = <span class="hljs-keyword">new</span> anyFunction();

<span class="hljs-comment">// The objects are different.</span>
obj !== anotherObj;

<span class="hljs-comment">// But their prototypes are the same.</span>
<span class="hljs-built_in">Object</span>.getPrototypeOf(obj) === <span class="hljs-built_in">Object</span>.getPrototypeOf(anotherObj);

<span class="hljs-comment">// Furthermore, they are the function&apos;s &quot;prototype&quot; property.</span>
<span class="hljs-built_in">Object</span>.getPrototypeOf(obj) === anyFunction.prototype;
</code></pre>
<p>With this, step 3 is automatized: it is no longer necessary to call <code>Object.create()</code> in order to establish the prototype chain between object and API (we get this automatically by using the <code>new</code> operator).</p>
<p>Finally, by calling it with <code>new</code>, <strong>the function receives as its context object (<code>this</code>) the element that is being created</strong>, which allows us to set its attributes.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Hero</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">this</span>.name = name;
    <span class="hljs-keyword">this</span>.sword = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.shield = <span class="hljs-literal">null</span>;
}

<span class="hljs-keyword">var</span> hero = <span class="hljs-keyword">new</span> Hero(<span class="hljs-string">&apos;Link&apos;</span>);
hero;
</code></pre>
<p>If the function returns nothing, <strong>the result of the operator <code>new</code> will be the new object</strong>. This automatizes step 5: returning the new object is no longer necessary, as this return is implicit to using <code>new</code>.</p>
<p>Notice what the constructor for a point object would look like:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Point</span>(<span class="hljs-params">x, y</span>) </span>{
    <span class="hljs-keyword">this</span>.x = x;
    <span class="hljs-keyword">this</span>.y = y;
}
</code></pre>
<p>As for the shot:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Shot</span>(<span class="hljs-params">position, velocity</span>) </span>{
    <span class="hljs-keyword">this</span>._position = position;
    <span class="hljs-keyword">this</span>._velocity = velocity;
}

<span class="hljs-comment">// The prototype does already exist, but we are adding the method advance() to it</span>
Shot.prototype.advance = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>._position.y += <span class="hljs-keyword">this</span>._velocity;
};
</code></pre>
<p>Now, creating the objects is a matter of using <code>new</code>. We will also use our new type, <code>Point</code>, to pass the position to the shot:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> enemyShot = <span class="hljs-keyword">new</span> Shot(<span class="hljs-keyword">new</span> Point(<span class="hljs-number">15</span>, <span class="hljs-number">15</span>), <span class="hljs-number">2</span>);
<span class="hljs-keyword">var</span> allyShot = <span class="hljs-keyword">new</span> Shot(<span class="hljs-keyword">new</span> Point(<span class="hljs-number">15</span>, <span class="hljs-number">585</span>), <span class="hljs-number">-2</span>);
enemyShot !== allyShot;
</code></pre>
<h2 id="inheritance">Inheritance</h2>
<p>We have seen how objects with attributes are created; also how to do it efficiently, by using constructors and the prototype chain.</p>
<p>Now we shall see how an <strong>inheritance relationship</strong> is created. Remember the example for enemies and the player ship in the prior lesson:</p>
<p><img src="images/space-invaders-hierarchy-EN.png" alt="Inheritance relationship between ship, enemies and the allied ship"></p>
<p>We will need our points and shots:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Point</span>(<span class="hljs-params">x, y</span>) </span>{
    <span class="hljs-keyword">this</span>.x = x;
    <span class="hljs-keyword">this</span>.y = y;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Shot</span>(<span class="hljs-params">position, velocity</span>) </span>{
    <span class="hljs-keyword">this</span>._position = position;
    <span class="hljs-keyword">this</span>._velocity = velocity;
}

Shot.prototype.advance = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>._position.y += <span class="hljs-keyword">this</span>._velocity;
};
</code></pre>
<p>The constructor and the methods for the enemies could be:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Enemy</span>(<span class="hljs-params">graphic, position, score</span>) </span>{
    <span class="hljs-keyword">this</span>._graphic = graphic;
    <span class="hljs-keyword">this</span>._currentDirection = <span class="hljs-string">&apos;right&apos;</span>;
    <span class="hljs-keyword">this</span>._position = position;
    <span class="hljs-keyword">this</span>._score = score;
}

Enemy.prototype.moveLeft = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">this</span>._position.x -= <span class="hljs-number">2</span>; };
Enemy.prototype.moveRight = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">this</span>._position.x += <span class="hljs-number">2</span>; };
Enemy.prototype.advance = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">this</span>._position.y += <span class="hljs-number">2</span>; };

Enemy.prototype.shoot = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> firePosition = <span class="hljs-keyword">new</span> Position(<span class="hljs-keyword">this</span>._position.x, <span class="hljs-keyword">this</span>._position.y + <span class="hljs-number">10</span>);
    <span class="hljs-keyword">var</span> shot = <span class="hljs-keyword">new</span> Shot(firePosition, <span class="hljs-number">2</span>);
    <span class="hljs-keyword">return</span> shot;
};
</code></pre>
<p>And here, the implementation for the allied ship:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Ally</span>(<span class="hljs-params">position</span>) </span>{
    <span class="hljs-keyword">this</span>._graphic = <span class="hljs-string">&apos;ally.png&apos;</span>;
    <span class="hljs-keyword">this</span>._position = position;
}

Ally.prototype.moveLeft = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">this</span>._position.x -= <span class="hljs-number">2</span>; };
Ally.prototype.moveRight = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">this</span>._position.x += <span class="hljs-number">2</span>; };

Ally.prototype.shoot = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> firePosition = <span class="hljs-keyword">new</span> Position(<span class="hljs-keyword">this</span>._position.x, <span class="hljs-keyword">this</span>._position.y - <span class="hljs-number">10</span>);
    <span class="hljs-keyword">var</span> shot = <span class="hljs-keyword">new</span> Shot(firePosition, <span class="hljs-number">-2</span>);
    <span class="hljs-keyword">return</span> shot;
};
</code></pre>
<p>Now we can generalize and think of a constructor that envelopes the properties that are common to both types:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Ship</span>(<span class="hljs-params">graphic, position</span>) </span>{
    <span class="hljs-keyword">this</span>._graphic = graphic;
    <span class="hljs-keyword">this</span>._position = position;
}

Ship.prototype.moveLeft = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">this</span>._position.x -= <span class="hljs-number">2</span>; };
Ship.prototype.moveRight = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">this</span>._position.x += <span class="hljs-number">2</span>; };
</code></pre>
<p>In this case, it is probably best not to include the <code>shoot</code> method, since some ships shoot upwards and others downwards. We will not include <code>advance</code> either, as it is exclusive to enemies.</p>
<p><img src="images/space-invaders-hierarchy-constructor-EN.png" alt="Constructor hierarchy"></p>
<p>Keep in mind that, from now on, the constructors for both the allied ship and the enemies will first ask the ship constructor to create a ship, and then customize it.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Enemy</span>(<span class="hljs-params">graphic, position, score</span>) </span>{
    Ship.apply(<span class="hljs-keyword">this</span>, [graphic, position]);
    <span class="hljs-keyword">this</span>._currentDirection = <span class="hljs-string">&apos;right&apos;</span>;
    <span class="hljs-keyword">this</span>._score = score;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Ally</span>(<span class="hljs-params">position</span>) </span>{
    Ship.apply(<span class="hljs-keyword">this</span>, [<span class="hljs-string">&apos;ally.png&apos;</span>, position]);
}
</code></pre>
<p>With <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Function/apply" target="_blank"><code>apply</code></a> we can execute a function specifying its context object, as well as its parameters.</p>
<p>With the previous configuration, all new instances of enemies and allies will first go through the <code>Ship</code> constructor, which will set the <strong>common attributes</strong>; these instances will then be modified individually by the relevant constructor, in order for them to become enemies or allies.</p>
<p>As for the API, it would be ideal to have a prototype chain after the following fashion:</p>
<ul>
<li><p>Enemy (or ally) attributes are included in the instance itself.</p>
</li>
<li><p>The specific API for the <code>Enemy</code> or <code>Ally</code> types is in the <code>prototype</code> property of that type&apos;s constructor.</p>
</li>
<li><p>The API common to the <code>Enemy</code> and <code>Ally</code> types is in the <code>prototype</code> property of the <code>Ship</code> constructor.</p>
</li>
</ul>
<pre><code>var enemy = new Enemy()             Enemy.prototype      Ship.prototype
{ _position: ..., _score: ... } --&gt; { advance: ... } --&gt; { moveLeft: ... }
enemy._score -----&#x2191;                   &#x2191;                    &#x2191;
enemy.advance ------------------------|                    |
enemy.moveLeft --------------------------------------------|
</code></pre><p>As was the case for the example in the previous section, it is necessary to create the chain from the rear to the front. The link between instances and constructors is provided by JavaScript upon using <code>new</code>, but the link between the <code>prototype</code> property from <code>Enemy</code> and from <code>Ship</code> <strong>has to be manually set</strong>.</p>
<p>Try the following:</p>
<pre><code class="lang-js"><span class="hljs-comment">// Inspects Enemy&apos;s prototype.</span>
Enemy.prototype;

<span class="hljs-comment">// Links both prototype properties.</span>
Enemy.prototype = <span class="hljs-built_in">Object</span>.create(Ship.prototype);

<span class="hljs-comment">// Inspects the prototype property again and scans for differences.</span>
Enemy.prototype;

<span class="hljs-comment">// Corrects the constructor property.</span>
Enemy.prototype.constructor = Enemy;

<span class="hljs-comment">// Adds the method specific to the type Enemy.</span>
Enemy.prototype.advance = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>._position.y += <span class="hljs-number">2</span>;
};

<span class="hljs-comment">// Another specific method.</span>
Enemy.prototype.shoot = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> firePosition = <span class="hljs-keyword">new</span> Point(<span class="hljs-keyword">this</span>._position.x, <span class="hljs-keyword">this</span>._position.y + <span class="hljs-number">10</span>);
    <span class="hljs-keyword">var</span> shot = <span class="hljs-keyword">new</span> Shot(firePosition, <span class="hljs-number">2</span>);
    <span class="hljs-keyword">return</span> shot;
};
</code></pre>
<p>And for the <code>Ally</code> type:</p>
<pre><code class="lang-js"><span class="hljs-comment">// The same for the ally.</span>
Ally.prototype = <span class="hljs-built_in">Object</span>.create(Ship.prototype);
Ally.prototype.constructor = Ally;

Ally.prototype.shoot = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> firePosition = <span class="hljs-keyword">new</span> Point(<span class="hljs-keyword">this</span>._position.x, <span class="hljs-keyword">this</span>._position.y - <span class="hljs-number">10</span>);
    <span class="hljs-keyword">var</span> shot = <span class="hljs-keyword">new</span> Shot(firePosition, <span class="hljs-number">-2</span>);
    <span class="hljs-keyword">return</span> shot;
};
</code></pre>
<p>Now we can finally create an enemy and an ally by using their constructors:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> enemy = <span class="hljs-keyword">new</span> Enemy(<span class="hljs-string">&apos;enemy1.png&apos;</span>, <span class="hljs-keyword">new</span> Point(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>), <span class="hljs-number">40</span>);
<span class="hljs-keyword">var</span> ally = <span class="hljs-keyword">new</span> Ally(<span class="hljs-keyword">new</span> Point(<span class="hljs-number">10</span>, <span class="hljs-number">590</span>));

<span class="hljs-built_in">Object</span>.getPrototypeOf(ally) === Ally.prototype;
<span class="hljs-built_in">Object</span>.getPrototypeOf(enemy) === Enemy.prototype;
Ally.prototype !== Enemy.prototype;
<span class="hljs-built_in">Object</span>.getPrototypeOf(Ally.prototype) === <span class="hljs-built_in">Object</span>.getPrototypeOf(Enemy.prototype);
<span class="hljs-built_in">Object</span>.getPrototypeOf(Ally.prototype) === Ship.prototype;
</code></pre>
<p>We can also check where every property is:</p>
<pre><code class="lang-js">enemy.hasOwnProperty(<span class="hljs-string">&apos;_score&apos;</span>);
enemy.hasOwnProperty(<span class="hljs-string">&apos;advance&apos;</span>);
enemy.hasOwnProperty(<span class="hljs-string">&apos;moveLeft&apos;</span>);

Enemy.prototype.hasOwnProperty(<span class="hljs-string">&apos;_score&apos;</span>);
Enemy.prototype.hasOwnProperty(<span class="hljs-string">&apos;advance&apos;</span>);
Enemy.prototype.hasOwnProperty(<span class="hljs-string">&apos;moveLeft&apos;</span>);

Ship.prototype.hasOwnProperty(<span class="hljs-string">&apos;_score&apos;</span>);
Ship.prototype.hasOwnProperty(<span class="hljs-string">&apos;advance&apos;</span>);
Ship.prototype.hasOwnProperty(<span class="hljs-string">&apos;moveLeft&apos;</span>);
</code></pre>
<h2 id="polymorphism">Polymorphism</h2>
<p>The inheritance relationships we have just established allow us to say that an enemy is an instance of the <code>Enemy</code> type, but also of the <code>Ship</code> type. <strong>A given instance can have multiple shapes, thanks to inheritance</strong>. In object-oriented programming this is called <strong>polymorphism</strong>.</p>
<p>Alternately, we can say an enemy is an instance of <code>Enemy</code> because it has the <code>Enemy</code> API, or that it is an instance of <code>Ship</code> because it has the <code>Ship</code> API. This is equivalent to saying that the <code>prototype</code> properties of <code>Enemy</code> and <code>Ship</code> are in the object&apos;s prototype chain.</p>
<p>The <code>instanceof</code> operator returns true if the <code>prototype</code> property of the function to the operator&apos;s right is in the prototype chain of the object to the left of the operator.</p>
<pre><code class="lang-js">enemy <span class="hljs-keyword">instanceof</span> Enemy;  <span class="hljs-comment">// Enemy.prototype is the first link.</span>
enemy <span class="hljs-keyword">instanceof</span> Ship;   <span class="hljs-comment">// Ship.prototype is the second.</span>
enemy <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>; <span class="hljs-comment">// Object.prototype, the third.</span>

enemy <span class="hljs-keyword">instanceof</span> Ally;   <span class="hljs-comment">// Ally.prototype is not in the chain.</span>
</code></pre>
<p>Regarding the state, it is convenient to know which constructor has built the object, so that we can know at a glance which attributes it will contain. This is equivalent to determining which is the function whose <code>prototype</code> property is the <strong>first link</strong> in the prototype chain.</p>
<p>Given that the prototype objects come with a built in <code>constructor</code> property, which by default points to the function which owns the prototype object, all we need is to access the <code>constructor</code> property through the instance.</p>
<pre><code class="lang-js">enemy.constructor;
enemy.constructor === Enemy; <span class="hljs-comment">// it was built by Enemy, not by Ship.</span>
enemy.constructor !== Ship; <span class="hljs-comment">// it is true that Ship was used, but nothing else.</span>
</code></pre>
<h3 id="duck-typing">Duck typing</h3>
<blockquote>
<p>In other words, don&apos;t check whether it IS-a duck: check whether it
QUACKS-like-a duck, WALKS-like-a duck, etc, etc, depending on exactly what
subset of duck-like behaviour you need to play your language-games with.</p>
</blockquote>
<p><a href="https://groups.google.com/forum/?hl=en#!msg/comp.lang.python/CCs2oJdyuzc/NYjla5HKMOIJ" target="_blank">Alex Martelli on polymorphism</a></p>
<p>The quote refers to how it is not so much a matter of checking whether something is an instance of a type, as rather checking whether it has the necessary functionality.</p>
<p>JavaScript is so dynamic that the <code>instanceof</code> operator and the <code>constructor</code> property only make sense if the conventions we have just covered are followed.</p>
<p>Nothing prevents us from deleting the <code>constructor</code> property from a prototype or overwriting it in a specific object. As a matter of fact, in the newer versions of JavaScript, an object&apos;s prototype can change after the object&apos;s construction.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="../0201-poo/" class="navigation navigation-prev " aria-label="Previous page: Object-oriented programming">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../0203-modelo-de-ejecucion/" class="navigation navigation-next " aria-label="Next page: The JavaScript execution model">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"The JavaScript data model","level":"1.3.2","depth":2,"next":{"title":"The JavaScript execution model","level":"1.3.3","depth":2,"path":"02-javascript/0203-modelo-de-ejecucion/index.md","ref":"02-javascript/0203-modelo-de-ejecucion/index.md","articles":[]},"previous":{"title":"Object-oriented programming","level":"1.3.1","depth":2,"path":"02-javascript/0201-poo/index.md","ref":"02-javascript/0201-poo/index.md","articles":[]},"dir":"ltr"},"config":{"plugins":[],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"language":"es","gitbook":"*"},"file":{"path":"02-javascript/0202-modelo-de-datos/index.md","mtime":"2017-08-22T18:17:00.000Z","type":"markdown"},"gitbook":{"version":"3.2.2","time":"2017-08-22T18:37:55.899Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

